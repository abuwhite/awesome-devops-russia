## Docker

### Что такое Docker? В чем отличие контейнера от образа?

Docker — это инструмент, позволяющий запускать приложения в изолированных контейнерах.

Образ — шаблон приложения, который содержит слои файловой системы в режиме "только-чтение".

Контейнер — запущенный образ приложения, который кроме нижних слоев в режиме "только чтение" содержит верхний слой в режиме "чтение-запись".

### Какие инструкции есть у Dockerfile?

| Инструкция | Описание |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `FROM` | Задаёт базовый (родительский) образ. |
| `LABEL` | Описывает метаданные. Например — сведения о том, кто создал и поддерживает образ. |
| `ENV` | Устанавливает постоянные переменные среды. |
| `RUN` | Выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов. |
| `COPY` | Копирует в контейнер файлы и директории. |
| `ADD` | Копирует файлы и директории в контейнер, может распаковывать локальные .tar-файлы. |
| `CMD` | Описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD. |
| `WORKDIR` | Задаёт рабочую директорию для следующей инструкции. |
| `ARG` | Задаёт переменные для передачи Docker во время сборки образа. |
| `ENTRYPOINT` | Предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются. |
| `EXPOSE` | Указывает на необходимость открыть порт. |
| `VOLUME` | Создаёт точку монтирования для работы с постоянным хранилищем. |

### Чем отличается `CMD` от `ENTRYPOINT` в Dockerfile?

Инструкции `CMD` и `ENTRYPOINT` выполняются в момент запуска контейнера, только инструкция `CMD` позволяет переопределить передаваемые команде аргументы.

**Пример 1. `CMD`:**
Опишем сборку образа в Dockerfile.
```
FROM alpine  
CMD ["ping", "8.8.8.8"]  
```
В инструкцию `CMD` передаются 2 аргумента. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```shell
$ docker run test
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=32.976 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=31.998 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=31.843 ms
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 31.708/33.316/36.823 ms
```
Теперь передадим 2 новых аргумента для запуска контейнера.
```shell
$ docker run test traceroute 1.1.1.1
traceroute to 1.1.1.1 (1.1.1.1), 30 hops max, 46 byte packets
 1  172.17.0.1 (172.17.0.1)  0.017 ms  0.016 ms  0.009 ms
 2  192.168.168.1 (192.168.168.1)  0.996 ms  1.553 ms  2.069 ms
 3  *  *  *
 4  lag-2-435.bgw01.samara.ertelecom.ru (85.113.62.125)  1.454 ms  1.427 ms  1.984 ms
 5  172.68.8.3 (172.68.8.3)  19.685 ms  15.722 ms  15.565 ms
 6  172.68.8.2 (172.68.8.2)  15.846 ms  22.696 ms  35.093 ms
 7  one.one.one.one (1.1.1.1)  17.439 ms  17.670 ms  24.202 ms
```
`ping` заменен на traceroute, IP адрес заменен на 1.1.1.1.

**Пример 2. `ENTRYPOINT`:**
Опишем сборку образа в Dockerfile.
```dockerfile
FROM alpine  
ENTRYPOINT ["ping", "8.8.8.8"]
```
В инструкцию `ENTRYPOINT` передаются 2 аргумента. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```shell
$ docker run test2
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=36.189 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=44.120 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=44.584 ms
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 36.189/41.631/44.584 ms
```
Теперь передадим и изменим один из аргументов для запуска контейнера.
```shell
$ docker run test2 ping 1.1.1.1
BusyBox v1.31.1 () multi-call binary.

Usage: ping [OPTIONS] HOST

Send ICMP ECHO_REQUEST packets to network hosts

	-4,-6		Force IP or IPv6 name resolution
	-c CNT		Send only CNT pings
	-s SIZE		Send SIZE data bytes in packets (default 56)
	-i SECS		Interval
	-A		Ping as soon as reply is recevied
	-t TTL		Set TTL
	-I IFACE/IP	Source interface or IP address
	-W SEC		Seconds to wait for the first response (default 10)
			(after all -c CNT packets are sent)
	-w SEC		Seconds until ping exits (default:infinite)
			(can exit earlier with -c CNT)
	-q		Quiet, only display output at start
			and when finished
	-p HEXBYTE	Pattern to use for payload
```
Как видим, аргумент передать контейнеру нельзя.

**Пример 3. `ENTRYPOINT` и `CMD`:**
Опишем сборку образа в Dockerfile.
```dockerfile
FROM alpine  
ENTRYPOINT ["ping"]
CMD ["8.8.8.8"]
```
В инструкцию `ENTRYPOINT` передаётся аргумент `ping`, в CMD передаётся аргумент 8.8.8.8. Выполним сборку образа `docker build -t test .` и запустим контейнер.
```shell
$ docker run test3
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=43 time=41.176 ms
64 bytes from 8.8.8.8: seq=1 ttl=43 time=32.875 ms
64 bytes from 8.8.8.8: seq=2 ttl=43 time=40.395 ms
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 32.875/38.148/41.176 ms
```
Пробуем изменить 2 аргумента.
```shell
$ docker run test3 traceroute 1.1.1.1
BusyBox v1.31.1 () multi-call binary.

Usage: ping [OPTIONS] HOST

Send ICMP ECHO_REQUEST packets to network hosts

	-4,-6		Force IP or IPv6 name resolution
	-c CNT		Send only CNT pings
	-s SIZE		Send SIZE data bytes in packets (default 56)
	-i SECS		Interval
	-A		Ping as soon as reply is recevied
	-t TTL		Set TTL
	-I IFACE/IP	Source interface or IP address
	-W SEC		Seconds to wait for the first response (default 10)
			(after all -c CNT packets are sent)
	-w SEC		Seconds until ping exits (default:infinite)
			(can exit earlier with -c CNT)
	-q		Quiet, only display output at start
			and when finished
	-p HEXBYTE	Pattern to use for payload
```
Изменить 2 аргумента невозможно. Заменим аргумент инструкции `CMD`.
```shell
$ docker run test3 1.1.1.1    
PING 1.1.1.1 (1.1.1.1): 56 data bytes
64 bytes from 1.1.1.1: seq=0 ttl=58 time=31.412 ms
64 bytes from 1.1.1.1: seq=1 ttl=58 time=19.400 ms
64 bytes from 1.1.1.1: seq=2 ttl=58 time=15.814 ms
^C
--- 1.1.1.1 ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 15.814/22.208/31.412 ms
```
При такой сборке образа команды `ENTRYPOINT` и `CMD` при запуске контейнера будут запущены последовательно, но аргумент возможно изменить только для `CMD`.

### Чем отличается *`COPY`* от *`ADD`* в Dockerfile?

`COPY` копирует файлы и папки с хоста в контейнер. `ADD` может делать то же самое, но ещё распаковывать архивы.

### Какие есть best practices для написания Dockerfile?

1. Запускать только один процесс на контейнер.
2. Стараться объединять несколько команд `RUN` в одну для уменьшения количества слоёв образа.
3. Часто изменяемые слои образа необходимо располагать ниже по уровню, чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все нижеследующие слои будут пересобираться.
4. Указывать явные версии образов в инструкции `FROM`, чтобы избежать случая, когда выйдет новая версия образа с тегом `latest`.
5. При установке пакетов указывать версии пакетов.
6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
7. Использовать `multistage build` для сборки артефакта в одном контейнере и размещении его в другом.




---
title: "Что такое Docker"
authors:
  - igsekor
contributors:
  - furtivite
editors:
  - tachisis
keywords:
  - докер
  - контейнер
  - container
tags:
  - article
---


Docker — это технология, которая позволяет создавать и использовать приложения в «родном» окружении. В основе Docker лежит идея: если приложение работает у вас, то оно должно работать где угодно. Способ этого добиться очень простой — нужно упаковать настройки окружения вместе с приложением.

Docker чаще всего применяется для развёртывания серверных приложений.

## Как понять

Запуск готового веб-приложения — наиболее популярный сценарий использования. Демка Docker — самое простое, что можно сделать «из коробки». Вам не пришлось устанавливать и запускать веб-сервер, не пришлось разбираться с какими-либо настройками, вы не трудились устанавливать у себя [Node.js](/tools/nodejs-tooling) и не столкнулись ни с какими сложностями. Представьте, что вы передали проект другому разработчику, и вам не приходится возиться с тем, чтобы проект запускался, не приходится говорить: «А у меня все работало 😞»

Без Docker вы, скорее всего, действовали бы так:

1. Узнали операционную систему на компьютере разработчика.
2. Сформировали сценарий или инструкцию настройки окружения.
3. Протестировали, как развёртывается ваше приложение.
4. Передали приложение разработчику и ждали результаты.

Ситуация будет ещё сложнее, если вы и другой разработчик используете разные операционные системы. С Docker все намного проще! Вы создаёте конфигурацию, и если она работает у вас, то заработает у всех.

Docker упаковывает приложение так, что будет счастлив любой, кто его получит 😇

Давайте разберёмся, как это происходит. Что должен делать Docker с вашим приложением, какое окружение он должен подготовить?

Рассмотрим пример с демкой от создателей Docker. Когда вы выполнили команду `docker run`, произошло следующее:

1. Docker нашёл и загрузил приложение с именем `docker/getting-started` из реестра приложений Docker Hub. Приложение уже было заботливо упаковано со всеми необходимыми ему утилитами и программами. Такая упаковка называется _образ_ (Docker Image). Образ обычно содержит в себе операционную систему на базе Linux, стартовую конфигурацию для установки служб, утилит, приложений, зависимостей проекта — все это называется окружением приложения.
1. Docker создал _контейнер_ (Docker Container) на основе образа. Контейнер — это конкретный экземпляр образа на вашем компьютере. Отношение «образ — контейнер» примерно такое же, как у пары «класс — объект класса» в [ООП](/js/oop).
1. Docker запустил контейнер с веб-сервером Nginx внутри, и веб-приложение «Справка по Docker» заработало. Для вашей операционной системы запустить контейнер — это все равно что запустить любое приложение или сервис.

Вы просто начали использовать веб-приложение, никаких сложностей.

![Модель стандартного применения Docker](images/1.png)

Перед тем, как мы научимся готовить образ сами, необходимо разобраться с терминами. Лучше сделать это на берегу 😎

### Важные службы

**Движок Docker Engine** — приложение для управления объектами Docker. Оно включает в себя три компонента:

1. сервер (Docker Daemon);
1. интерфейс (Docker API);
1. консольный клиент (Docker CLI).

Ваш компьютер называется _Docker Host_. Все операции, которые мы выполняем в интерфейсе или через [консоль](https://docs.docker.com/engine/reference/commandline/cli/), выполняются сервером через [API движка](https://docs.docker.com/engine/api/).

**Docker Desktop** — пакет приложений с графическим интерфейсом, включающий специальную виртуальную машину для работы с движком, визуальный интерфейс (Dashboard), консольный клиент, инструменты для работы с реестром Docker Hub и пр.

Для платформы Mac и Windows невозможно использовать Docker Engine напрямую, необходимо запустить виртуальную машину. Docker Desktop содержит такую виртуальную машину. Все процессы в ней оптимизированы, контейнеры работают быстрее, но определённые [ограничения](https://docs.docker.com/desktop/faqs/) все равно присутствуют.

### Объекты Docker

**Образ (Docker Image)** — прототип будущего контейнера, содержащий операционную систему, приложение или проект для сборки приложения. Образы состоят из слоёв. Каждый новый слой — это надстройка над предыдущим. Слои должны надстраиваться поверх базового образа, формируя новый. Например, базовым образом может быть образ операционной системы.

Слои образа описываются в специальных файлах конфигурации. Как правило, для этого используется Dockerfile. Конфигурационный файл всегда начинается с указания базового образа, имя которого прописывается после директивы `FROM`. Дальше могут идти разные надстройки (новые слои) образа. Вы можете задать рабочую папку проекта с помощью директивы `WORKDIR`, скопировать файлы в эту рабочую папку директивой `COPY`, запустить выполнение команды или нескольких команд в терминале директивой `RUN`. Пример конфигурации:

```dockerfile
FROM ubuntu:18.04
WORKDIR /app
COPY . .
RUN apt-get update && apt-get upgrade
```

**Контейнер (Docker Container)** — уже собранное и запущенное приложение в изолированном окружении, которое формируется послойно, в соответствии с образом. Каждый новый слой расширяет функциональность предыдущего, формируя стек используемых инструментов, платформ и настроек системных служб. Файловая система контейнера тоже стековая ([Union File Systems](https://www.terriblecode.com/blog/how-docker-images-work-union-file-systems-for-dummies/)). Каталоги и файлы отдельного слоя образа накладываются друг на друга, образуя единое целое.

**Том (Docker Volume)** — папка, которую можно подключить (говорят _«примонтировать»_) к контейнерам. Папка может быть связана с конкретной папкой на вашем компьютере, а может быть как бы сетевой для контейнеров на вашем компьютере. Тома необходимы для хранения файлов конфигурации, критических с точки зрения безопасности, файлов баз данных, файлов, которые нельзя удалять после окончания работы приложения.

**Сеть (Docker Network)** — виртуальная локальная сеть, которая позволяет совместно использовать несколько запущенных контейнеров и соединять запущенный контейнер с вашим компьютером. В основном вы будете использовать три режима работы сетевой инфраструктуры Docker:

1. `bridge` — когда контейнеры могут взаимодействовать между собой как веб-сервер и база данных.
1. `host` — для доступа к локальному сетевому окружению на вашем компьютере.
1. `none` — сеть для контейнеров полностью отключена.


## Как пользоваться

Ключи командного интерфейса Docker CLI хорошо проработаны и похожи на консольные команды в bash. Например, дополнительный ключ `prune` позволяет удалять неиспользуемые объекты. Ключ `rm` служит для удаления, а ключ `ls` для просмотра объектов. Объекты Docker в обязательном порядке имеют уникальное имя. Если вы не именуете объект специально, то имя объекта формируется с помощью хэш-функции. Если вы попытаетесь создать объект одного и того же типа с уже использованным именем, в этом вам будет отказано. Как же пользоваться консольным клиентом?

### Мониторинг запущенных контейнеров

- `docker ps` — просмотр запущенных контейнеров.
- `docker ps -a` — ключ `-a` выводит и запущенные, и остановленные контейнеры.
- `docker ps -s` — ключ `-s` выводит дисковое пространство, используемое каждым запущенным контейнером.
- `docker ps -f name=hello` — ключ `-f` фильтрует список контейнеров по имени, например, `hello`.

Полный список ключей для команды `docker ps` доступен [в документации](https://docs.docker.com/engine/reference/commandline/ps/).

### Запуск контейнеров

Для запуска контейнера, который доступен локально или на Docker Hub, выполните команду:

```bash
docker run --name test -i -t hello
```

Ключ `--name` используется для установки имени запущенного контейнера. Ключи `-i` и `-t` указывают, что для запуска контейнера будет использоваться [стандартный поток ввода](https://ru.wikipedia.org/wiki/Стандартные_потоки) и [терминал TTY](https://ru.wikipedia.org/wiki/TTY-абстракция) соответственно. Для того чтобы при запуске контейнера примонтировать том, который будет связан с папкой на вашем компьютере, а потом получить доступ к контейнеру через терминал, выполните команду:

```bash
docker run -t -i --mount type=bind,src=/data,dst=/data hello bash
```

Полный список ключей для команды `docker run` доступен [в документации](https://docs.docker.com/engine/reference/commandline/run/).

### Управление образами

Вы можете получить список всех доступных локально образов с помощью команды:

```bash
docker image ls
```

Ключи `prune`, `rm` действуют обычным способом, позволяя удалить неиспользуемые или конкретные образы соответственно. Для работы с реестром необходимо использовать следующие команды:

- `docker image pull hello` — загрузка образа с именем hello из реестра;
- `docker image push hello` — отправка образа с именем hello в реестр;
- `docker image inspect hello` — полная информация о контейнере `hello`;
- `docker image build` — собрать контейнер из текущей папки с учётом Dockerfile.

Полный список ключей для команды `docker image` доступен [в документации](https://docs.docker.com/engine/reference/commandline/image/).

### Управление контейнерами

Наиболее используемыми командами будут команды запуска и остановки контейнеров.

Команда для запуска контейнера:

```bash
docker container start
```

Команда для перезапуска контейнера:

```bash
docker container restart
```

Команда для остановки контейнера:

```bash
docker container stop
```

Команда для постановки контейнера на паузу:

```bash
docker container pause
```

Полный список ключей для команды `docker container` доступен [в документации](https://docs.docker.com/engine/reference/commandline/container/).

### Управление томами

- `docker volume ls` — вывод всех томов.
- `docker volume ls -f name=hello` — вывод всех томов с фильтрацией по имени, например, `hello`.
- `docker volume create hello` — создание нового тома, например, `hello`.
- `docker volume inspect hello` — исчерпывающая информация о томе.

Полный список ключей для команды `docker volume` доступен [в документации](https://docs.docker.com/engine/reference/commandline/volume/).